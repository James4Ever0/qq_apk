package com.tencent.mobileqq.shortvideo.videotransfer;

public class TransferConfig
{
  public static TransferConfig.ConfigData a(int paramInt)
  {
    TransferConfig.ConfigData localConfigData = new TransferConfig.ConfigData();
    switch (paramInt)
    {
    default: 
      localConfigData.jdField_a_of_type_Int = -1;
      return localConfigData;
    case 3: 
      localConfigData.jdField_a_of_type_Int = -1;
      return localConfigData;
    case 2: 
      localConfigData.jdField_a_of_type_JavaLangString = "uniform mat4 uMVPMatrix;\nuniform mat4 uTextureMatrix;\nattribute vec4 position;\nattribute vec4 inputTextureCoordinate;\nvarying highp vec2 textureCoordinate;\nvoid main()\n{\ngl_Position = uMVPMatrix * position;\ntextureCoordinate = (uTextureMatrix * inputTextureCoordinate).xy;\n}";
      localConfigData.b = "precision highp float;\nuniform sampler2D inputImageTexture;\nuniform sampler2D inputImageTexture2;\nuniform vec2 inputImageTextureSize;\nuniform vec2 inputImageTexture2Size;\nuniform vec2 timeRange; //start, duration\nuniform float time;\nvarying vec2 textureCoordinate;\nvoid main()\n{\nhighp vec2 size = inputImageTextureSize - inputImageTexture2Size;\nif (time > timeRange.x && time < timeRange.y + timeRange.x)\n{\nsize.x = 0.5;\nsize.y = 0.5;\n}\nelse\n{\nsize.x = 0.5;\nsize.y = 0.5;\n};\ngl_FragColor = texture2D(inputImageTexture, textureCoordinate) * size.x + texture2D(inputImageTexture2, textureCoordinate) * size.y;\n}";
      localConfigData.jdField_a_of_type_Long = 1000L;
      localConfigData.jdField_a_of_type_Int = paramInt;
      return localConfigData;
    case 1: 
      localConfigData.jdField_a_of_type_JavaLangString = null;
      localConfigData.b = "precision highp float;\n\nvarying vec2 textureCoordinate;\n\nuniform sampler2D inputImageTexture;\nuniform vec2 inputImageTextureSize;\n\nuniform sampler2D inputImageTexture2;\nuniform vec2 inputImageTexture2Size;\n\nuniform vec2 timeRange; //start, duration\nuniform float time;\n\nfloat ImageRepeatCount = 2.0;\nfloat RotateMaxAngle = 45.0;\nfloat SpeedPowValue = 5.0;\nfloat MotionBlurMaxStrength = 0.05;\nfloat MaxStretchRatio = 3.5;\nfloat StretchSpeedPowValue = 3.0;\n\nfloat getAnimationTime()\n{\n    float animationTime = 0.0;\n    if (timeRange.x <= 0.0 || timeRange.y <= 0.0)\n        return animationTime;\n    \n    if (time > timeRange.x && time < timeRange.x + timeRange.y) {\n        animationTime = (time - timeRange.x) / timeRange.y;\n    }\n    return animationTime;\n}\n\nfloat adjustTextureCoordinateIfOutOfRange(float coordinateValue)\n{\n    float adjustValue = mod(abs(coordinateValue), 2.0);\n    if (adjustValue > 1.0)\n        adjustValue =  2.0 - adjustValue;\n    return adjustValue;\n}\n\n//滚动\n\nvec2 getScroll(vec2 inputTextureCoordinate, float animationTime)\n{\n    vec2 outputTextureCoordinate = inputTextureCoordinate;\n    if (animationTime < 0.5)\n        outputTextureCoordinate.y += pow(animationTime, SpeedPowValue) * pow(2.0, SpeedPowValue) * ImageRepeatCount;\n    else\n        outputTextureCoordinate.x += pow((1.0 - animationTime), SpeedPowValue) * pow(2.0, SpeedPowValue) * ImageRepeatCount * (-1.0);\n    return outputTextureCoordinate;\n}\n\n//旋转\n\nfloat getRotateAngleFromTime(float animationTime)\n{\n    if (animationTime < 0.5)\n        return pow(animationTime, SpeedPowValue) * pow(2.0, SpeedPowValue) * RotateMaxAngle;\n    else\n        return pow((1.0 - animationTime), SpeedPowValue) * pow(2.0, SpeedPowValue) * RotateMaxAngle * (-1.0);\n}\n\nvec2 getRotateDirectionFromTime(float animationTime)\n{\n    float angle;\n    if (animationTime < 0.5)\n        angle = pow(animationTime, SpeedPowValue) * pow(2.0, SpeedPowValue) * RotateMaxAngle;\n    else\n        angle = RotateMaxAngle * 2.0 - pow((1.0 - animationTime), SpeedPowValue) * pow(2.0, SpeedPowValue) * RotateMaxAngle;\n    float degree = radians(angle);\n    return vec2(sin(degree), cos(degree));\n}\n\nvec2 getRotate(vec2 inputTextureCoordinate, float angle, vec2 rotateCenter)\n{\n    vec2 textureCoordinateUse;\n    float degree = radians(angle);\n    float c = cos(degree);\n    float s = sin(degree);\n    textureCoordinateUse.x = (inputTextureCoordinate.x - rotateCenter.x) * c - (inputTextureCoordinate.y - rotateCenter.y) * s + rotateCenter.x;\n    textureCoordinateUse.y = (inputTextureCoordinate.x - rotateCenter.x) * s + (inputTextureCoordinate.y - rotateCenter.y) * c + rotateCenter.y;\n    return textureCoordinateUse;\n}\n\n//运动模糊\n\nfloat getBlurStrengthFromTime(float animationTime)\n{\n    float atime = animationTime;\n    if (animationTime > 0.5) {\n        atime = 1.0 - animationTime;\n    }\n    return MotionBlurMaxStrength * pow(2.0, SpeedPowValue - 1.0) * pow(atime, SpeedPowValue - 1.0);\n}\n\nfloat rand (vec2 inputTextureCoordinate)\n{\n    return fract(sin(dot(inputTextureCoordinate.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec4 getColor(sampler2D imageTexture, vec2 inputTextureCoordinate)\n{\n    vec2 textureCoordinateUse = inputTextureCoordinate;\n    textureCoordinateUse.x = adjustTextureCoordinateIfOutOfRange(inputTextureCoordinate.x);\n    textureCoordinateUse.y = adjustTextureCoordinateIfOutOfRange(inputTextureCoordinate.y);\n    return texture2D(imageTexture, textureCoordinateUse);\n}\n\nvec4 motionBlur(sampler2D imageTexture, vec2 inputTextureCoordinate, vec2 speed)\n{\n    vec2 texCoord = inputTextureCoordinate.xy / vec2(1.0).xy;\n    vec3 color = vec3(0.0);\n    float total = 0.0;\n    float offset = rand(inputTextureCoordinate);\n    for (float t = 0.0; t <= 20.0; t++) {\n        float percent = (t + offset) / 20.0;\n        float weight = 4.0 * (percent - percent * percent);\n        color += getColor(imageTexture, texCoord + speed * percent).rgb * weight;\n        total += weight;\n    }\n    return vec4(color / total, 1.0);\n}\n\nvec2 getMotionTransition(vec2 inputTextureCoordinate, float animationTime)\n{\n    vec2 textureCoordinateUse = getScroll(inputTextureCoordinate, animationTime);\n    float angle = getRotateAngleFromTime(animationTime);\n    vec2 rotateCenter = getScroll(vec2(0.5, 0.5), animationTime);\n    textureCoordinateUse = getRotate(textureCoordinateUse, angle, rotateCenter);\n    return textureCoordinateUse;\n}\n\n//拉伸\n\nvec2 getStretchTransition(vec2 inputTextureCoordinate, float animationTime)\n{\n    vec2 textureCoordinateUse = inputTextureCoordinate;\n    float currentMaxStretchRatio = 1.0;\n    if (animationTime < 0.5)\n        currentMaxStretchRatio = pow(animationTime, StretchSpeedPowValue) * pow(2.0, StretchSpeedPowValue) * (MaxStretchRatio - 1.0) + 1.0;\n    else\n        currentMaxStretchRatio = pow((1.0 - animationTime), StretchSpeedPowValue) * pow(2.0, StretchSpeedPowValue) * (MaxStretchRatio - 1.0) + 1.0;\n    float stretchRatio = (currentMaxStretchRatio - 1.0) * (1.0 - inputTextureCoordinate.y) + 1.0;\n    textureCoordinateUse.x = (inputTextureCoordinate.x - 0.5) / stretchRatio + 0.5;\n    return textureCoordinateUse;\n}\n\n//main\n\nvoid main()\n{\n    float animationTime = getAnimationTime();\n    if (animationTime > 0.0 && animationTime < 0.99) {\n        vec2 textureCoordinateUse = getStretchTransition(textureCoordinate, animationTime);\n        textureCoordinateUse = getMotionTransition(textureCoordinateUse, animationTime);\n        \n        float timeInterval = 0.01;\n        vec2 textureCoordinateNext = getStretchTransition(textureCoordinate, animationTime + timeInterval);\n        textureCoordinateNext = getMotionTransition(textureCoordinateNext, animationTime + timeInterval);\n        vec2 speed = (textureCoordinateNext - textureCoordinateUse) / timeInterval * MotionBlurMaxStrength;\n        \n        if (animationTime < 0.5)\n            gl_FragColor = motionBlur(inputImageTexture2, textureCoordinateUse, speed);\n        else\n            gl_FragColor = motionBlur(inputImageTexture, textureCoordinateUse, speed);\n    }\n    else {\n        gl_FragColor = texture2D(inputImageTexture, textureCoordinate);\n    }\n}\n\n";
      localConfigData.jdField_a_of_type_Long = 1200L;
      localConfigData.jdField_a_of_type_Int = paramInt;
      return localConfigData;
    case 4: 
      localConfigData.jdField_a_of_type_JavaLangString = "uniform mat4 uMVPMatrix;\nuniform mat4 uTextureMatrix;\nattribute vec4 position;\nattribute vec4 inputTextureCoordinate;\nvarying highp vec2 textureCoordinate;\nvoid main()\n{\ngl_Position = uMVPMatrix * position;\ntextureCoordinate = (uTextureMatrix * inputTextureCoordinate).xy;\n}";
      localConfigData.b = "precision highp float;\nuniform sampler2D inputImageTexture;\nuniform sampler2D inputImageTexture2;\nuniform vec2 inputImageTextureSize;\nuniform vec2 inputImageTexture2Size;\nuniform vec2 timeRange; //start, duration\nuniform float time;\nvarying vec2 textureCoordinate;\nconst int passes = 6;\nfloat intensity = 0.02;\nfloat getAnimationTime()\n{\n    float animationTime = 0.0;\n    if (timeRange.x <= 0.0 || timeRange.y <= 0.0)\n        return animationTime;\n    \n    if (time > timeRange.x && time < timeRange.x + timeRange.y) {\n        animationTime = (time - timeRange.x) / timeRange.y;\n    }\n    return animationTime;\n}\n\nvec4 getBlur(float time, sampler2D texture, vec2 coordinate){\n   vec4 c1 = vec4(0.0);\n   float disp = intensity*time;\n   for (int xi=0; xi<passes; xi++)\n    {\n        float x = float(xi) / float(passes) - 0.5;\n        for (int yi=0; yi<passes; yi++)\n        {\n            float y = float(yi) / float(passes) - 0.5;\n            vec2 v = vec2(x,y);\n            float d = disp;\n            c1 += texture2D( texture, coordinate + d*v);\n        }\n    }\n   c1 /= float(passes*passes);\n   return c1;\n}void main()\n{\n   float animationTime = getAnimationTime();\n   if (animationTime > 0.0 && animationTime < 0.99) {\n       vec4 c1 = vec4(0.0);\n       vec4 c2 = vec4(0.0);\n       if(animationTime>0.0 && animationTime<=0.4){\n           c2 = getBlur(smoothstep(0.0 , 0.4, animationTime), inputImageTexture2, textureCoordinate);\n           gl_FragColor = c2;\n       }else{\n           c2 = getBlur(smoothstep(0.0 , 0.4, animationTime), inputImageTexture2, textureCoordinate);\n           c1 = getBlur(1.0-smoothstep(0.4 , 0.99, animationTime), inputImageTexture, textureCoordinate);\n           gl_FragColor = vec4(mix(c2.rgb, c1.rgb, smoothstep(0.4 , 0.99, animationTime)),1.0);\n       }    }\n    else {\n        gl_FragColor = texture2D(inputImageTexture, textureCoordinate);\n    }\n}";
      localConfigData.jdField_a_of_type_Long = 1000L;
      localConfigData.jdField_a_of_type_Int = paramInt;
      return localConfigData;
    case 5: 
      localConfigData.jdField_a_of_type_JavaLangString = "uniform mat4 uMVPMatrix;\nuniform mat4 uTextureMatrix;\nattribute vec4 position;\nattribute vec4 inputTextureCoordinate;\nvarying highp vec2 textureCoordinate;\nvoid main()\n{\ngl_Position = uMVPMatrix * position;\ntextureCoordinate = (uTextureMatrix * inputTextureCoordinate).xy;\n}";
      localConfigData.b = "precision highp float;\nvarying vec2 textureCoordinate;\nvarying vec2 textureCoordinate2;\nuniform sampler2D inputImageTexture;\nuniform sampler2D inputImageTexture2;\nuniform vec2 timeRange; //start, duration\nuniform float time;\n\nvec3 color = vec3(0.0);\nfloat colorPhase = 0.4 ; \n\nfloat getAnimationTime()\n{\n    float animationTime = 0.0;\n    if (timeRange.x <= 0.0 || timeRange.y <= 0.0)\n        return animationTime;\n\n    if (time > timeRange.x && time < timeRange.x + timeRange.y) {\n        animationTime = (time - timeRange.x) / timeRange.y;\n    }\n    return animationTime;\n}\n\nvec4 getTransitionColor(vec2 uv, float time) {\n  vec4 fromCol = texture2D(inputImageTexture2, uv);\n  vec4 toCol = texture2D(inputImageTexture, uv);\n  return mix(\n    mix(vec4(color, 1.0), fromCol, smoothstep(1.0-colorPhase, 0.0, time)),\n    mix(vec4(color, 1.0), toCol, smoothstep(colorPhase, 1.0, time)),\n    time);\n}\n\nvoid main()\n{\n  float time = getAnimationTime();\n  if (time > 0.0 && time < 0.99) {\n\tgl_FragColor = getTransitionColor(textureCoordinate, time);\n  } else {\n\tgl_FragColor = texture2D(inputImageTexture, textureCoordinate);\n  }\n}";
      localConfigData.jdField_a_of_type_Long = 1200L;
      localConfigData.jdField_a_of_type_Int = paramInt;
      return localConfigData;
    case 6: 
      localConfigData.jdField_a_of_type_JavaLangString = "uniform mat4 uMVPMatrix;\nuniform mat4 uTextureMatrix;\nattribute vec4 position;\nattribute vec4 inputTextureCoordinate;\nvarying highp vec2 textureCoordinate;\nvoid main()\n{\ngl_Position = uMVPMatrix * position;\ntextureCoordinate = (uTextureMatrix * inputTextureCoordinate).xy;\n}";
      localConfigData.b = "precision highp float;\nvarying vec2 textureCoordinate;\nvarying vec2 textureCoordinate2;\nuniform sampler2D inputImageTexture;\nuniform sampler2D inputImageTexture2;\nuniform vec2 timeRange; //start, duration\nuniform float time;\n\nfloat nQuick = 0.8;\n\nfloat getAnimationTime()\n{\n    float animationTime = 0.0;\n    if (timeRange.x <= 0.0 || timeRange.y <= 0.0)\n        return animationTime;\n\n    if (time > timeRange.x && time < timeRange.x + timeRange.y) {\n        animationTime = (time - timeRange.x) / timeRange.y;\n    }\n    return animationTime;\n}\n\nvec2 zoom(vec2 uv, float amount) {\n  return 0.5 + ((uv - 0.5) * (1.0-amount));\t\n}\n\nvec4 getTransitionColor(vec2 uv, float time) {\n  vec4 fromCol = texture2D(inputImageTexture2, zoom(uv, smoothstep(0.0, nQuick, time)));\n  vec4 toCol = texture2D(inputImageTexture, uv);\n  return mix(fromCol,toCol,smoothstep(0.4, 1.0, time));\n}\n\nvoid main()\n{\n  float time = getAnimationTime();\n  if (time > 0.0 && time < 0.99) {\n\tgl_FragColor = getTransitionColor(textureCoordinate, time);\n  } else {\n\tgl_FragColor = texture2D(inputImageTexture, textureCoordinate);\n  }\n}";
      localConfigData.jdField_a_of_type_Long = 1200L;
      localConfigData.jdField_a_of_type_Int = paramInt;
      return localConfigData;
    }
    localConfigData.jdField_a_of_type_JavaLangString = "uniform mat4 uMVPMatrix;\nuniform mat4 uTextureMatrix;\nattribute vec4 position;\nattribute vec4 inputTextureCoordinate;\nvarying highp vec2 textureCoordinate;\nvoid main()\n{\ngl_Position = uMVPMatrix * position;\ntextureCoordinate = (uTextureMatrix * inputTextureCoordinate).xy;\n}";
    localConfigData.b = "precision highp float;\nvarying vec2 textureCoordinate;\nvarying vec2 textureCoordinate2;\nuniform sampler2D inputImageTexture;\nuniform sampler2D inputImageTexture2;\nuniform vec2 timeRange; //start, duration\nuniform float time;\n\nvec2 direction = vec2(1.0, 1.0);\nfloat smoothness = 0.5;\n \nconst vec2 center = vec2(0.5, 0.5);\n \n\nfloat getAnimationTime()\n{\n    float animationTime = 0.0;\n    if (timeRange.x <= 0.0 || timeRange.y <= 0.0)\n        return animationTime;\n\n    if (time > timeRange.x && time < timeRange.x + timeRange.y) {\n        animationTime = (time - timeRange.x) / timeRange.y;\n    }\n    return animationTime;\n}\n\nvec4 getTransitionColor(vec2 uv, float time) {\n  vec4 fromCol = texture2D(inputImageTexture2, uv);\n  vec4 toCol = texture2D(inputImageTexture, uv);\n  vec2 v = normalize(direction);\n  v /= abs(v.x)+abs(v.y);\n  float d = v.x * center.x + v.y * center.y;\n  float m = (1.0-step(time, 0.0)) * (1.0 - smoothstep(-smoothness, 0.0, v.x * uv.x + v.y * uv.y - (d-0.5+time*(1.+smoothness))));\n  return mix(fromCol, toCol, m);\n}\n\nvoid main()\n{\n  float time = getAnimationTime();\n  if (time > 0.0 && time < 0.99) {\n\tgl_FragColor = getTransitionColor(textureCoordinate, time);\n  } else {\n\tgl_FragColor = texture2D(inputImageTexture, textureCoordinate);\n  }\n}";
    localConfigData.jdField_a_of_type_Long = 1200L;
    localConfigData.jdField_a_of_type_Int = paramInt;
    return localConfigData;
  }
}


/* Location:           L:\local\mybackup\temp\qq_apk\com.tencent.mobileqq\classes3.jar
 * Qualified Name:     com.tencent.mobileqq.shortvideo.videotransfer.TransferConfig
 * JD-Core Version:    0.7.0.1
 */